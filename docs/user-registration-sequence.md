# User Registration Sequence

This document describes the user registration flow between auth-service and user-service in the microservices architecture.

## Overview

The user registration process follows a distributed pattern where:
1. **auth-service** handles registration requests and authentication data
2. **user-service** manages user profile data
3. **RabbitMQ** facilitates asynchronous communication between services

## Sequence Diagram

```
Client → auth-service → user-service → auth-service
   ↓         ↓            ↓             ↓
 POST    Publish      Create User   Update with
/register  Event      in DB         user_id
```

## Detailed Flow

### 1. Client Registration Request
- **Endpoint**: `POST /auth/register`
- **Input**: `AuthUserCreate` schema (username, email, password)
- **Service**: auth-service

### 2. auth-service Processing
1. **Password Security**: Temporarily stores password in Redis using `save_password_to_redis()`
2. **Event Publishing**: Publishes user creation event to RabbitMQ
   - **Exchange**: `user_events`
   - **Routing Key**: `user.sync`
   - **Message Body**:
     ```json
     {
       "event_type": "user.created",
       "user_data": {
         "username": "user123",
         "email": "user@example.com",
         "password_key": "redis_key_for_password"
       }
     }
     ```
3. **Response**: Returns `202 Accepted` with confirmation message

### 3. user-service Processing
1. **Message Consumption**: Consumes message from `user_creation_queue`
2. **User Creation**: Creates user in user-service database
   - **Table**: `users`
   - **Fields**: `id`, `username`, `email`
3. **Response Publishing**: Publishes response back to auth-service
   - **Exchange**: `auth_events`
   - **Routing Key**: `user.created`
   - **Message Body**:
     ```json
     {
       "event_type": "user.created",
       "user_data": {
         "id": "uuid-from-user-service",
         "username": "user123",
         "email": "user@example.com",
         "original_request": {
           "username": "user123",
           "email": "user@example.com",
           "password_key": "redis_key_for_password"
         }
       }
     }
     ```

### 4. auth-service Completion
1. **Message Consumption**: Consumes response from `auth_user_creation_queue`
2. **Password Retrieval**: Gets password from Redis using `password_key`
3. **User Creation**: Creates user in auth-service database
   - **Table**: `auth_users`
   - **Fields**: `id`, `username`, `email`, `hashed_password`, `user_id`
   - **Key Point**: `user_id` column stores the UUID from user-service
4. **Cleanup**: Deletes password from Redis after successful creation

## Database Schema

### auth-service (auth_users table)
```sql
CREATE TABLE auth_users (
    id UUID PRIMARY KEY,
    username VARCHAR UNIQUE NOT NULL,
    email VARCHAR UNIQUE NOT NULL,
    hashed_password VARCHAR NOT NULL,
    user_id UUID UNIQUE,  -- References user-service user.id
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

### user-service (users table)
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    username VARCHAR UNIQUE NOT NULL,
    email VARCHAR UNIQUE NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

## Key Components

### RabbitMQ Configuration
- **Exchanges**: 
  - `user_events` (Topic exchange)
  - `auth_events` (Topic exchange)
- **Queues**:
  - `user_creation_queue` (user-service listens)
  - `auth_user_creation_queue` (auth-service listens)

### Redis Usage
- **Purpose**: Temporary password storage during async processing
- **Key Format**: Generated by `save_password_to_redis()`
- **Cleanup**: Automatically deleted after successful user creation

### Error Handling
- **Duplicate Detection**: Both services check for username/email duplicates
- **Rollback**: Database transactions are rolled back on errors
- **Password Security**: Redis keys are cleaned up even on failures
- **Message Durability**: RabbitMQ messages are persistent

## Security Considerations

1. **Password Storage**: Passwords are temporarily stored in Redis, not sent through messages
2. **Hashing**: Passwords are hashed using bcrypt before database storage
3. **Cleanup**: Temporary Redis keys are always cleaned up
4. **Unique Constraints**: Both services enforce username/email uniqueness

## Flow Timing

1. **Client Request**: Immediate 202 Accepted response
2. **Async Processing**: Background processing through RabbitMQ
3. **Completion**: auth-service user creation completes the flow
4. **Total Time**: Typically completes within seconds

## Files Involved

### auth-service
- `/api/v1/auth.py:48-80` - Registration endpoint
- `/crud/auth_user.py:54-93` - User creation with user_id
- `/messaging/auth_handler.py:12-78` - User creation response handler
- `/messaging/rabbitmq.py:164-166` - Event publishing
- `/models/auth_user.py:14` - user_id column definition

### user-service
- `/messaging/user_handler.py:12-55` - User creation request handler
- `/crud/user.py:22-45` - User creation
- `/messaging/rabbitmq.py:160-162` - Response publishing
- `/models/user.py:8-13` - User model definition

This distributed approach ensures data consistency while maintaining service independence and scalability.